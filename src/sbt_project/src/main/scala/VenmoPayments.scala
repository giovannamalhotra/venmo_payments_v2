import scala.io.Source
import org.json4s._
import org.json4s.native.JsonMethods._
import scala.collection.mutable.ArrayBuffer
import com.github.nscala_time.time.Imports._
import java.io._

//import org.json4s.JsonAST.JValue

/** --------------------------  Summary of the program steps ---------------------------------------------------
  *
  * 1. Validate input and output file names parameters
  *   a. Validate input and output file names were given when running the program (these are given in run.sh script)
  *   b. Validate input file exists. (Outputfile existence is not validated as it will be generated by the program)
  *
  * 2. Validate input data is in JSON format and no information is missing
  *
  * 3. Read transaction line from input File. Create Venmo Graph Class, call its "processTransaction" method (pass transaction line as parameter)
  *
  * 4. Inside processTransaction method:
  *   a. Determine new max time stamp
  *   b. Add new transaction to array of last transactions
  *   c. Loop through all transactions and only consider the ones that are within the 60-seconds window (from latest time stamp)
  *   d. If transaction is within the 60 second-window, then copy it to a new array of transactions.
  *      Also update graph adjacency list (vertexMap) with the connections for the actor and target
  *   e. Copy vertexMap (containing the connections for each user) to an array, sort and calculate new median degree
  *   f. Write new median degree to output file
  */

/** ----------------------------------------------------------------------------- */
/** Class Transaction - An instance corresponds to an individual transaction line */
/** ----------------------------------------------------------------------------- */
class Transaction(val line: String, lineNum: Int) {

  var created_time: String = ""
  var target: String = ""
  var actor: String = ""
  private var valid: Boolean = false

  def isValid(): Boolean = {
    return valid
  }

  def parseLine(): Boolean = {

    /** Validate line is in correct format and all required values are present */
    var validJSON = true
    var validData = true
    implicit val formats = DefaultFormats // for JSON parsing

    //transactionObject = parse(line).extract[transaction]

    var jsonInputObj = parse("")

    try {
      jsonInputObj = parse(line)
    }
    catch {
      case _: Throwable => validJSON = false
    }

    if (!validJSON) {
      println("Line #" + lineNum + " - Is not a valid JSON format")
      validData = false

    } else {

      if (((jsonInputObj \ "actor") == JNothing)) {
        println("Line #" + lineNum + " - Actor was not found")
        validData = false
      }
      else {
        this.actor = (jsonInputObj \ "actor").extract[String]
      }

      if (((jsonInputObj \ "target") == JNothing)) {
        println("Line #" + lineNum + " - Target was not found")
        validData = false
      }
      else {
        this.target = (jsonInputObj \ "target").extract[String]
      }

      if (((jsonInputObj \ "created_time") == JNothing)) {
        println("Line #" + lineNum + " - Created time was not found")
        validData = false
      }
      else {
        this.created_time = (jsonInputObj \ "created_time").extract[String]
      }
    }

    valid = validData
    return validData

  }

  // Parse Input when instantiating the class
  parseLine()

}

/** ----------------------------------------------------------------------------- */
/** Class VenmoGraph - Holds the collection of current transactions               */
/** ----------------------------------------------------------------------------- */
class VenmoGraph() {

  var transactionsArr = ArrayBuffer[Transaction]()  /** empty array that holds all transaction bbjects */
  var maxTimeStamp:Option[DateTime] = None  /** holds the maximum payment transaction timestamp */


  def calcMedian(arr: ArrayBuffer[Int]): Double = {

    var middle = arr.length/2
    var result: Double = 0
    if (arr.length % 2 != 0) {  /** Array length is odd */

      result = arr(Math.floor(middle).toInt)
      result = BigDecimal(result).setScale(2, BigDecimal.RoundingMode.HALF_UP).toDouble
    }
    else { /**  middle is even */
      result = (arr(middle - 1).toDouble + arr(middle).toDouble) / 2
      //println("Inside median method - arr(middle - 1):" + arr(middle - 1) + ", arr(middle):" + arr(middle) + ", result:" + result)
      result = BigDecimal(result).setScale(2, BigDecimal.RoundingMode.HALF_UP).toDouble
    }
    return result
  }


  def processTransaction(line: String, lineNum: Int, outputFile: File): Unit = {

    var transactionObj = new Transaction(line, lineNum)

    if (transactionObj.isValid ) {

      /** Convert transaction created_time (String) to nscala-time DateTime */
      var transTime = DateTime.parse(transactionObj.created_time)

      var newMaxTimeStamp = maxTimeStamp

      /** Determine max timestamp */
      if (newMaxTimeStamp.isEmpty) {
        newMaxTimeStamp = Some(transTime)
      } else {

        if (transTime > newMaxTimeStamp.get) {
          newMaxTimeStamp = Some(transTime)
        }
      }

      //println("----------------------------------------------------------------")
      //println("Process Transaction: a.target:" + o.target + ", a.actor:" + o.actor + ", o.created_time:" + o.created_time + ", transTime:" + transTime + ", newMaxTimeStamp:" + newMaxTimeStamp)
      //println("newMaxTimeStamp.get:" + newMaxTimeStamp.get + ", newMaxTimeStamp.get - 60.seconds:" + (newMaxTimeStamp.get - 60.seconds).toString  )

      /** Add transaction object to array of transactions  */
      transactionsArr += transactionObj

      /** create an empty map - adjacency list - to keep track of connections for each vertex (actor or target) */
      //var vertexMap = scala.collection.mutable.Map[String, Int]()
      var vertexMap = scala.collection.mutable.Map[String, ArrayBuffer[String]]()

      /** Loop through last transactions, only consider the ones that are within the 60-seconds window */
      var transTempArr = ArrayBuffer[Transaction]()
      for (a <- transactionsArr) {

        var lineTransTime = DateTime.parse(a.created_time)
        //println("a.target:" + a.target + ", a.actor:" + a.actor + ", a.created_time:" + a.created_time + ", lineTransTime:" + lineTransTime)

        if (lineTransTime > newMaxTimeStamp.get - 60.seconds) {
          /** Transaction time is within 60-secs window, then copy it to temporary array */
          transTempArr += a
          //println("Transaction will be copied")

          /** Increment connections for the actor */
          if (vertexMap.contains(a.actor)) {
            /** If user already exists in the Adjacency List (HashMap), then increment its connections */
            //vertexMap(a.actor) += 1
            //vertexMap(a.actor) += a.target

            if (!vertexMap(a.actor).contains(a.target)) {
              vertexMap(a.actor) += a.target
            }
          }
          else {
            //vertexMap += (a.actor -> 1)
            vertexMap += (a.actor -> ArrayBuffer(a.target))
          }

          /** Increment connections for the target */
          if (vertexMap.contains(a.target)) {
            /** If user already exists in the Adjacency List (HashMap), then increment its connections */
            //vertexMap(a.target) += 1
            //vertexMap(a.target) += a.actor

            if (!vertexMap(a.target).contains(a.actor)) {
              vertexMap(a.target) += a.actor
            }

          }
          else {
            //vertexMap += (a.target -> 1)
            vertexMap += (a.target -> ArrayBuffer(a.actor))
          }
        }
      }


      /** Copy HasMap (containing number of connections for each individual) to Array, sort and calculate new median degree */
      var medianArray = ArrayBuffer[Int]()
      for ((k, v) <- vertexMap) {
        //medianArray += v
        medianArray += v.length
      }
      medianArray = medianArray.sorted
      //var medianValStr = median(medianArray).toString
      var medianValStr = "%.2f".format(calcMedian(medianArray)).toString

      /** Write new media degree to output file */
      //println("medianArray:" + medianArray + ", map:" + vertexMap)
      println("MEDIAN: " + medianValStr)
      val write = new PrintWriter(new FileOutputStream(outputFile, true))
      write.write(medianValStr + "\n")
      write.close()


      /** Update maxTimeStamp */
      maxTimeStamp = newMaxTimeStamp

      /** Update transactions array */
      transactionsArr = transTempArr
    }

    else {

      println("Transaction # " + lineNum + " is not valid, it will be ignored")
    }
  }

}


/** ----------------------------------------------------------------------------- */
/**                      App Main object with main method                         */
/** ----------------------------------------------------------------------------- */
object VenmoPayments {

  def main(args: Array[String]): Unit = {

    /** ----------------------------------------------- */
    /** Validate input and output file names parameters */
    /** ----------------------------------------------- */

    /** Capture parameters for input and output files. Example of input and output:  */
    //inputFileName = "../venmo_input/venmo-trans.txt"  -- outputFileName = "../venmo_output/output.txt"
    var inputFileName = ""
    var outputFileName = ""

    if (args.length <= 0) {
      println("----------------------------")
      println("MISSING PARAMETERS - Please provide Input and Output file names as parameters")
      println("----------------------------")
      return
    }

    if (args.length == 1) {
      println("----------------------------")
      println("MISSING PARAMETER - Please provide second parameter as the Output file name")
      println("----------------------------")
      return
    }

    if (args.length >= 2) {

      inputFileName = args(0)
      outputFileName = args(1)

      if (!new java.io.File(inputFileName).exists) {

        println("----------------------------")
        println("MISSING INPUT FILE - Input File '" + inputFileName + "' was not found")
        println("----------------------------")
        return
      }
    }


    /** ------------------ */
    /** Create output file */
    /** ------------------ */
    val outputFile = new File(outputFileName)

    val writerObj = new PrintWriter(outputFile)
    writerObj.close()



    /** --------------------------------- */
    /** Process transactions line by line */
    /** --------------------------------- */
    implicit val formats = DefaultFormats // for JSON parsing format

    var venmoGraphObj = new VenmoGraph()
    var lineNum = 0

    for (line <- Source.fromFile(inputFileName).getLines) {
        lineNum += 1
        venmoGraphObj.processTransaction(line, lineNum, outputFile)
    }


  }

}

