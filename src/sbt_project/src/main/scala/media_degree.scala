import scala.io.Source
import org.json4s._
import org.json4s.native.JsonMethods._

import scala.collection.mutable.ArrayBuffer
import com.github.nscala_time.time.Imports._
import java.io._

//import org.json4s.JsonAST.JValue

/** --------------------------  Summary of the program steps ---------------------------------------------------
  *
  * 1. Validate input and output file names parameters
  *   a. Validate input and output file names were given when running the program (this are given in run.sh script)
  *   b. Validate input file exists. (Outfile existence is not validated as it will be generated by the program
  *
  * 2. Validate input data is in JSON format and no information is missing
  *
  * 3. Read transaction line from input File. Create transaction object and pass it to "processTransaction" method
  *
  * 4. Inside processTransaction method:
  *   a. Determine new max time stamp
  *   b. Add new transaction to array of last transactions
  *   c. Loop through all transactions and only consider the ones that are within the 60-seconds window (from latest time stamp)
  *   d. If transaction is within the 60 second-window, then copy it to a new array of transactions.
  *      Also update graph adjacency list (vertexMap) with the connections for the actor and target
  *   e. Copy vertexMap (containing the connections for each user) to an array, sort and calculate new median degree
  *   f. Write new median degree to output file
  */


/** ------------------------------------------------------------------- */
/** Class for mapping the transaction line received in input file */
/** ------------------------------------------------------------------- */
case class transaction(

     created_time: String,
     target: String,
     actor: String
)


/** ------------------------------------------------------------------- */
/**     MEDIA-DEGREE program                                            */
/** ------------------------------------------------------------------- */
object media_degree {

  var transactionsArr = ArrayBuffer[transaction]()  /** empty array that holds all transactionObjects */
  var maxTimeStamp:Option[DateTime] = None  /** holds the maximum payment transaction timestamp */

  /** ------------------------------------------------------------------- */
  /**  Method to calculate the median of an ArrayBuffer of Int values     */
  /** ------------------------------------------------------------------- */
  def median(arr: ArrayBuffer[Int]): Double = {

    var middle = arr.length/2
    var result: Double = 0
    if (arr.length % 2 != 0) {  /** Array length is odd */

        result = arr(Math.floor(middle).toInt)
        result = BigDecimal(result).setScale(2, BigDecimal.RoundingMode.HALF_UP).toDouble
    }
    else { /**  middle is even */
      result = (arr(middle - 1).toDouble + arr(middle).toDouble) / 2
      //println("Inside median method - arr(middle - 1):" + arr(middle - 1) + ", arr(middle):" + arr(middle) + ", result:" + result)
      result = BigDecimal(result).setScale(2, BigDecimal.RoundingMode.HALF_UP).toDouble
    }
    return result
  }


  /** ------------------------------------------------------------------- */
  /**  Stand alone function to process a transaction. Called from "main"  */
  /** ------------------------------------------------------------------- */
  def processTransaction(o: transaction, outputFile: File): Unit = {

    /** Convert transaction created_time (String) to nscala-time DateTime */
    var transTime = DateTime.parse(o.created_time)

    var newMaxTimeStamp = maxTimeStamp

    /** Determine max timestamp */
    if (newMaxTimeStamp.isEmpty) {
      newMaxTimeStamp = Some(transTime)
    } else {

      if (transTime > newMaxTimeStamp.get ) {
        newMaxTimeStamp = Some(transTime)
      }
    }

    //println("----------------------------------------------------------------")
    //println("Process Transaction: a.target:" + o.target + ", a.actor:" + o.actor + ", o.created_time:" + o.created_time + ", transTime:" + transTime + ", newMaxTimeStamp:" + newMaxTimeStamp)
    //println("newMaxTimeStamp.get:" + newMaxTimeStamp.get + ", newMaxTimeStamp.get - 60.seconds:" + (newMaxTimeStamp.get - 60.seconds).toString  )

    /** Add transaction object to array of transactions  */
    transactionsArr += o

    /** create an empty map - adjacency list - to keep track of connections for each vertex (actor or target) */
    //var vertexMap = scala.collection.mutable.Map[String, Int]()
    var vertexMap = scala.collection.mutable.Map[String,  ArrayBuffer[String]]()

    /** Loop through last transactions, only consider the ones that are within the 60-seconds window */
    var transTempArr = ArrayBuffer[transaction]()
    for( a <- transactionsArr ){

      var lineTransTime = DateTime.parse(a.created_time)
      //println("a.target:" + a.target + ", a.actor:" + a.actor + ", a.created_time:" + a.created_time + ", lineTransTime:" + lineTransTime)

      if (lineTransTime > newMaxTimeStamp.get - 60.seconds) {
        /** Transaction time is within 60-secs window, then copy it to temporary array */
        transTempArr += a
        //println("Transaction will be copied")

        /** Increment connections for the actor */
        if ( vertexMap.contains(a.actor) ) { /** If user already exists in the Adjacency List (HashMap), then increment its connections */
          //vertexMap(a.actor) += 1
          //vertexMap(a.actor) += a.target

          if (!vertexMap(a.actor).contains(a.target)) {
            vertexMap(a.actor) += a.target
          }
        }
        else {
          //vertexMap += (a.actor -> 1)
          vertexMap += (a.actor -> ArrayBuffer(a.target) )
        }

        /** Increment connections for the target */
        if ( vertexMap.contains(a.target) ) { /** If user already exists in the Adjacency List (HashMap), then increment its connections */
          //vertexMap(a.target) += 1
          //vertexMap(a.target) += a.actor

          if (!vertexMap(a.target).contains(a.actor)) {
            vertexMap(a.target) += a.actor
          }

        }
        else {
          //vertexMap += (a.target -> 1)
          vertexMap += (a.target -> ArrayBuffer(a.actor) )
        }
      }
    }


    /** Copy HasMap (containing number of connections for each individual) to Array, sort and calculate new median degree */
    var medianArray = ArrayBuffer[Int]()
    for ((k,v) <- vertexMap) {
      //medianArray += v
      medianArray += v.length
    }
    medianArray = medianArray.sorted
    //var medianValStr = median(medianArray).toString
    var medianValStr = "%.2f".format(median(medianArray)).toString

    /** Write new media degree to output file */
    //println("medianArray:" + medianArray + ", map:" + vertexMap)
    println("MEDIAN: " + medianValStr)
    val write = new PrintWriter(new FileOutputStream(outputFile,true))
    write.write(medianValStr + "\n")
    write.close()


    /** Update maxTimeStamp */
    maxTimeStamp = newMaxTimeStamp

    /** Update transactions array */
    transactionsArr = transTempArr

  }


  /** ------------------------------------------------------------------- */
  /**  MAIN procedure                                                     */
  /** ------------------------------------------------------------------- */
  def main(args: Array[String]): Unit = {

    /** Capture parameters for input and output files */
    //val inputFileName = "../venmo_input/venmo-trans.txt"
    //val outputFileName = "../venmo_output/output.txt"
    var inputFileName = ""
    var outputFileName = ""

    /** -------------------------------------------- */
    /** Validate file names were given as parameters */
    /** -------------------------------------------- */

    if (args.length <= 0) {
      println("----------------------------")
      println("MISSING PARAMETERS - Please provide Input and Output file names as parameters")
      println("----------------------------")
      return
    }

    if (args.length == 1) {
      println("----------------------------")
      println("MISSING PARAMETER - Please provide second parameter as the Output file name")
      println("----------------------------")
      return
    }

    if (args.length >= 2) {

      inputFileName = args(0)
      outputFileName = args(1)

      if (!new java.io.File(inputFileName).exists) {

        println("----------------------------")
        println("MISSING INPUT FILE - Input File '" + inputFileName + "' was not found")
        println("----------------------------")
        return
      }
    }

    //println("inputFileName:" + inputFileName + ", outputFileName:" + outputFileName)
    implicit val formats = DefaultFormats

    /** ------------------ */
    /** Create output file */
    /** ------------------ */
    val outputFile = new File(outputFileName)

    val writerObj = new PrintWriter(outputFile)
    writerObj.close()

    /** this variable will store the transaction line that is being processed */
    //var transactionObject = new transaction("","","")

    /** --------------------------------- */
    /** Process transactions line by line */
    /** --------------------------------- */
    var lineNum = 0
    for (line <- Source.fromFile(inputFileName).getLines) {

      /** ------------------- */
      /** Validate input data */
      /** ------------------- */
      //transactionObject = parse(line).extract[transaction]
      lineNum += 1
      var validData = true
      var actor = ""
      var target = ""
      var created_time = ""

      var validJSON = true
      var jsonInputObj = parse("")

      try {
        jsonInputObj = parse(line)
      }
      catch {
        case _: Throwable => validJSON = false
      }

      if (!validJSON) {
        println("Line #" + lineNum + " - Is not a valid JSON format")

      } else {

        if (((jsonInputObj \ "actor") == JNothing)) {
          println("Line #" + lineNum + " - Actor was not found")
          validData = false
        }
        else {
          actor = (jsonInputObj \ "actor").extract[String]
        }

        if (((jsonInputObj \ "target") == JNothing)) {
          println("Line #" + lineNum + " - Target was not found")
          validData = false
        }
        else {
          target = (jsonInputObj \ "target").extract[String]
        }

        if (((jsonInputObj \ "created_time") == JNothing)) {
          println("Line #" + lineNum + " - Created time was not found")
          validData = false
        }
        else {
          created_time = (jsonInputObj \ "created_time").extract[String]
        }


        /** --------------------------------------------------------- */
        /** Process transaction only if the transaction data is valid */
        /** --------------------------------------------------------- */
        if (validData) {

          /** this variable will store the transaction line that is being processed */
          var transactionObject = new transaction(created_time, target, actor)
          //println("transactionObject before calling processTransaction:" + transactionObject)
          processTransaction(transactionObject, outputFile)

        }
      }
    }

  }
}